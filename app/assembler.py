"""
Module that encapsilates all assembling and disassembling logic for Dash.
"""
import binascii
import os 
import platform
import subprocess
import string
import struct
import sys
import tempfile

# third party modules
import capstone
import keystone


class AssemblerError(Exception):
  """Generic exception class for Assembler Errors."""
  pass


class Assembler(object):
  """Class to encapsilate all assembling and disassembling logic."""
  def __init__(self):
    """
    Constructor.
    
    Returns:
      A new Assembler instance
    """
    # we default to x86 in 32-bit mode
    self.asm_arch = keystone.KS_ARCH_X86
    self.asm_mode = keystone.KS_MODE_32
    self.disasm_arch = capstone.CS_ARCH_X86
    self.disasm_mode = capstone.CS_MODE_32
    self.assembler = keystone.Ks(self.asm_arch, self.asm_mode)
    self.disassembler = capstone.Cs(self.disasm_arch, self.disasm_mode)

  def UpdateStoreOpcodes(self, opcode_str, store):
    """
    Disassemble the resulting file from NASM and update the store state if 
    necessary.
    
    Args:
      opcode_str: a string of binary data 
                 (the contents of the file generated by nasm)
     
    Returns:
      N / A 
    
    Side Effects:
      Updates the values of the Opcode column
    """
    # disassemble the instructions accordingly
    cur_offset = 0
    for row in store.GetRowsIterator():
      row_asm = row.mnemonic
      instruction = None
      try:
        if row_asm:
          # find the end of the instruction
          if self.IsADataDefinitionInstruction(row_asm):
            end_char = self.FindEndCharFromMnemonic(row_asm)
            new_opcodes = opcode_str[cur_offset:opcode_str.find(end_char, cur_offset) + 1]
            cur_offset += len(new_opcodes)
          else:
            instruction = distorm3.Decompose(0, opcode_str[cur_offset:], bitw)[0]
            new_opcodes = instruction.instructionBytes
            cur_offset += instruction.size
        elif row.opcode:
          instruction = distorm3.Decompose(0, opcode_str[cur_offset:], bitw)[0]
          new_opcodes = instruction.instructionBytes
          cur_offset += instruction.size
        else:
          continue
  
        if instruction and \
           instruction.flowControl in ('FC_UNC_BRANCH', 'FC_CND_BRANCH', 'FC_CALL'):
          row.is_branch_or_call = True
        else:
          row.is_branch_or_call = False
          
        row.opcode = new_opcodes
        
        if row_asm and instruction and store.ContainsLabel(row_asm):
          row.mnemonic = store.ReplaceLabel(row, instruction)
        elif instruction:
          row.mnemonic = str(instruction)
          
        row.error = False
        store.UpdateRow(row.index, row)
      except:
        row.error = True
        break
      
      if cur_offset >= len(opcode_str):
        break

      
  def IsADataDefinitionInstruction(self, mnemonic):
    """
    Is this instruction a db, dw, dd, or dq instruction? 
    
    Args:
      mnemonic: a string mnemonic
      
    Returns:
      True if it's an instruction that defines data. False otherwise.
    """
    for inst in ['DB', 'DW', 'DD', 'DQ']:
      if mnemonic.upper().strip().startswith(inst):
        return True
    return False
  
  def Assemble(self, index, store):
    """Assemble the mnemonics provided in the store.
    
    This will assemble all instructions before and after in order to support 
    labels
    
    Args:
      index: an integer describing the currently selected row in the table.
      store: An AssemblyStore instance
    
    Returns:
      N / A
      
    Side Effects:
      Updates the assembly store at the given path (row index) 
    """
    store.ClearErrors();
    next_addr = None
    for row in store.GetRowsIterator():
      if not row.in_use:
        continue
      # check if this row contains a label and adjust the mnemonic (TODO)
      if not next_addr:
        next_addr = row.address
        
      try:
        encoded_bytes, count  = self.assembler.asm(row.mnemonic, addr=next_addr)
        row.opcode = binascii.unhexlify("".join(["%02x" % byte for byte in encoded_bytes]))
        next_addr += len(encoded_bytes)
        store.UpdateRow(row.index, row)
      except:
        store.SetErrorAtIndex(row.index)
        break
    return


  def Disassemble(self, index, store):
    """
    Disassembles the instruction given the opcode string taken from a row at
    the index provided.
    
    Args:
      index: an integer row index in the AssemblyStore
      store: The AssemblyStore instance
      
    Returns:
      N / A
      
    Side Effects:
      Updates the AssemblyStore row specified by the index.
    """
    row = store.GetRow(index)
    # disassemble and set in the store
    instructions = list(self.disassembler.disasm(row.opcode, row.address))
    
    if instructions:
      row.opcode = str(instructions[0].bytes)
      row.SetMnemonic("%s %s" % (instructions[0].mnemonic, instructions[0].op_str))
      
      store.UpdateRow(row.index, row)
      
      if len(instructions) > 1:
        for i in xrange(1, len(instructions)):
          store.CreateRowFromCapstoneInst(row.index + i, instructions[i])

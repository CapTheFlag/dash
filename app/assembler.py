"""
Module that encapsilates all assembling and disassembling logic for Dash.
"""
import binascii
import os 
import platform
import subprocess
import string
import struct
import sys
import tempfile

# third party modules
import capstone
import keystone


class AssemblerError(Exception):
  """Generic exception class for Assembler Errors."""
  pass


class Assembler(object):
  """Class to encapsilate assembling and disassembling logic."""
  def __init__(self):
    """
    Constructor.
    
    Returns:
      A new Assembler instance
    """
    # we default to x86 in 32-bit mode
    self.arch = keystone.KS_ARCH_X86
    self.mode = keystone.KS_MODE_32
    self.assembler = keystone.Ks(self.arch, self.mode)
    self.disassembler = capstone.Cs(self.arch, self.mode)

  def UpdateStoreOpcodes(self, opcode_str, store):
    """
    Disassemble the resulting file from NASM and update the store state if 
    necessary.
    
    Args:
      opcode_str: a string of binary data 
                 (the contents of the file generated by nasm)
     
    Returns:
      N / A 
    
    Side Effects:
      Updates the values of the Opcode column
    """
    # disassemble the instructions accordingly
    cur_offset = 0
    for row in store.GetRowsIterator():
      row_asm = row.mnemonic
      instruction = None
      try:
        if row_asm:
          # find the end of the instruction
          if self.IsADataDefinitionInstruction(row_asm):
            end_char = self.FindEndCharFromMnemonic(row_asm)
            new_opcodes = opcode_str[cur_offset:opcode_str.find(end_char, cur_offset) + 1]
            cur_offset += len(new_opcodes)
          else:
            instruction = distorm3.Decompose(0, opcode_str[cur_offset:], bitw)[0]
            new_opcodes = instruction.instructionBytes
            cur_offset += instruction.size
        elif row.opcode:
          instruction = distorm3.Decompose(0, opcode_str[cur_offset:], bitw)[0]
          new_opcodes = instruction.instructionBytes
          cur_offset += instruction.size
        else:
          continue
  
        if instruction and \
           instruction.flowControl in ('FC_UNC_BRANCH', 'FC_CND_BRANCH', 'FC_CALL'):
          row.is_branch_or_call = True
        else:
          row.is_branch_or_call = False
          
        row.opcode = new_opcodes
        
        if row_asm and instruction and store.ContainsLabel(row_asm):
          row.mnemonic = store.ReplaceLabel(row, instruction)
        elif instruction:
          row.mnemonic = str(instruction)
          
        row.error = False
        store.UpdateRow(row.index, row)
      except:
        row.error = True
        break
      
      if cur_offset >= len(opcode_str):
        break

      
  def IsADataDefinitionInstruction(self, mnemonic):
    """
    Is this instruction a db, dw, dd, or dq instruction? 
    
    Args:
      mnemonic: a string mnemonic
      
    Returns:
      True if it's an instruction that defines data. False otherwise.
    """
    for inst in ['DB', 'DW', 'DD', 'DQ']:
      if mnemonic.upper().strip().startswith(inst):
        return True
    return False
  
  def Assemble(self, index, store):
    """Assemble the mnemonics provided in the store.
    
    This will assemble all instructions before and after in order to support 
    labels
    
    Args:
      index: an integer describing the currently selected row in the table.
      store: An AssemblyStore instance
    
    Returns:
      N / A
      
    Side Effects:
      Updates the assembly store at the given path (row index) 
    """
    store.ClearErrors();
    opcodes = self.AssembleFile(self.CreateNasmFileText(store))
    
    if not opcodes or len(opcodes) < 1:
      store.SetErrorAtIndex(index)
      return
    
    self.UpdateStoreOpcodes(opcodes, store)


  def Disassemble(self, index, store):
    """
    Disassembles the instruction given the opcode string.
    
    Args:
      index: an integer describing the row index in the AssemblyStore
      store: The AssemblyStore instance
      
    Returns:
      N / A
      
    Side Effects:
      Updates the AssemblyStore row specified by the index.
    """
    row = store.GetRow(index)
    # try to turn the hex encoded string into binary 
    
    # determine the bit width constant    
    if store.bits == 32:
      bitw = distorm3.Decode32Bits
    elif store.bits == 64:
      bitw = distorm3.Decode64Bits
    else:
      bitw = distorm3.Decode16Bits
      
    # disassemble and set in the store
    instructions = list(self.disassembler.disasm(row.opcode, row.address))
    
    if instructions:
      row.opcode = instructions[0].instructionBytes
      row.SetMnemonic(str(instructions[0]))
      
      store.UpdateRow(row.index, row)
      
      if len(instructions) > 1:
        for i in xrange(1, len(instructions)):
          store.CreateRowFromCapstoneInst(row.index + i, instructions[i])
    
  
  def Reassemble(self, store):
    """
    Re-assembles all of the instructions in the store.
    """
    pass
    

  def SplitInst(self, asm_line):
    """
    Split an instruction into a dictionary of instruction, dst_op, 
    src_op, and optional_op.
    
    This is very naive.
    
    Args:
     asm_line: a string of assembly 
     
    Returns:
     a tuple with a  dictionary
    """ 
    inst = {'mnemonic:': '', 'dst_op': '', 'src_op': '', 'opt_op': ''}
    asm_fields = asm_line.split()
    inst['mnemonic'] = asm_fields[0]
    if inst['mnemonic'].lower() in ['db', 'dw', 'dd', 'dq']:
      return inst
    elif inst['mnemonic'].lower() in 'push':
      inst['src_op'] = asm_fields[-1]
      inst['dst_op'] = 'RSP'
      return inst
    elif inst['mnemonic'].lower() == 'pop':
      inst['src_op'] = 'RSP' 
      inst['dst_op'] = asm_fields[-1]
      return inst
    operands = asm_line.split(',')
    if len(operands) == 1:
      return inst
    elif len(operands) == 2:
      inst['dst_op'], inst['src_op'] = operands[0].strip(), operands[1].strip()
      # remove any prefixes and instructions
      inst['dst_op'] = inst['dst_op'].split()[-1].strip()
      return inst
    elif len(operands) == 3:
      inst['dst_op'], inst['src_op'] = operands[0].strip(), operands[1].strip()
      # remove any prefixes and instructions
      inst['dst_op'] = inst['dst_op'].split()[-1].strip()
      inst['opt_op'] = operands[-1].strip()
      return inst
    else:
      # default
      return inst
    
  #TODO refactor this into dash.py
  def TranslateUnicode(self, gui, uni_string, bit_width):
    """
    Decode and disassemble unicode escape sequences (e.g. "\u4141") storing them 
    in the gtk.ListStore
    
    Args:
      gui: a gtk.Window instance
      uni_string: a string containing unicode escape sequences
      bit_width: an integer either with a value of 16,32, or 64
    
    Returns:
      N / A
    """
    data = []
    ascii_bytes = ''
    binary = ''
  
    # Pull out all quoted strings and assume they're unicode escape sequences
    start = uni_string.find('\"') # First quote
    end = uni_string[start+1:].find('\"') + start + 1 # next quote 
    while (start < len(uni_string) and end < len(uni_string)):
      tmp_str = ""
      for char_to_remove in ["\"", "+", "\n"]:
        tmp_str += uni_string[start:end].replace(char_to_remove, '')
      data += tmp_str.split('\u')
  
      start = uni_string[end+1:].find('\"') 
      if start == -1:
        break
      start = start + end + 1# next after end quote
      end = uni_string[start+1:].find('\"')
      if end == -1:
        break
      end = end + start + 1  # next after start quote
  
    for word in data:
      if len(word) != 4:
        continue
      ascii_bytes += word[2:]
      ascii_bytes += word[:2]
  
    self.store.reset()
    self.store.bitwidth = bit_width
    gui.menu_set_bitwidth(bit_width)
    path = self.store.get_path(store.get_iter_root())
    self.Disassemble(self.store, path, ascii_bytes)

  def ImportBinary(self, gui, binary, bit_width):
    """Imports a binary of assembly."""
    self.store.reset()
    self.store.bit_width = bit_width
    gui.menu_set_bit_width(bit_width)
    path = store.get_path(store.get_iter_root())
    opcodes = binascii.hexlify(binary)
    self.Disassemble(path, opcodes)
    
  def ExtractNasmComment(self, asm_line):
    """
    Get the comment from a NASM line.
    
    Args:
      asm_line:
      
    Returns:
      jj
    """
    single_quote_count = 0
    double_quote_count = 0
    for i in xrange(len(asm_line)):
      if asm_line[i] == '\'':
        single_quote_count = (single_quote_count + 1) % 2
      elif asm_line[i] == '"':
        double_quote_count = (double_quote_count + 1) % 2
      if asm_line[i] == ';':
        # we're inside a comment
        if single_quote_count or double_quote_count:
          continue
        # we've found the first comment ;
        else:
          break
    if asm_line[i] != ';':
      i += 1
    return asm_line[:i], asm_line[i:]
    
    
  def ImportAssembly(self, gui, listing):
    """Imports a string listing of assembly."""
    self.store.reset()
    citer = self.store.get_iter_root()
    lines = listing.splitlines()
    
    #pdb.set_trace() 
    # TODO replace this with a grammar
    cur_label = ''
    cur_path = self.store.get_path(citer)
    prev_path = None
    for line in lines:
      # skip blank lines
      if line.strip() == '':
        continue
      # check for a label
      if line.endswith(':'):
        cur_label = line.replace(':','')
        continue
      # clean up line and extract
      asm = line.strip()
      # check for a comment
      asm, comment = self.ExtractNasmComment(asm)
      # add label to row
      if cur_label:
        self.store.set_label(cur_path, cur_label)
        cur_label = ''

      # add comment to row
      self.store.set_comment(cur_path, comment) 
       
      # deal with
      if asm.startswith('BITS'):
        self.store.bitwidth = asm.split()[1]
        gui.menu_set_bitwidth(self.store.bitwidth)
        continue
      else:
        self.store.set_assembly(cur_path, asm)
        self.store.insert_blank_row_after(cur_path)
        #self.store.Assemble(path, asm)
        prev_path = cur_path
        citer = self.store.iter_next(citer)
        cur_path = self.store.get_path(citer)
    
    self.Reassemble()
    
  def TranslatePyRB(self, gui, pyrb_string, bit_width):
    """
    Translate a python or ruby string to assembly and disassemble into the store.
    
    Args:
      gui: a gtk.Widget instance
      pyrb_string: a string
      bit_width: an integer with a value of 16,32, or 64
      
    Returns:
      jjj
    """
    buf = ''
    lines = pyrb_string.split()
    if len(lines) >= 1:
      for line in lines:
        # strip all extra contents
        line = line[line.find('"'):line.rfind('"')]
        line = line.replace('\\x', ' ').replace('"', '')
        buf += line
  
    self.store.reset()
    self.store.bitwidth = bit_width
    gui.menu_set_bitwidth(bit_width)
    path = self.store.get_path(self.store.get_iter_root())
    self.Disassemble(path, buf)

